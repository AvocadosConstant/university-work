\documentclass{article}

\usepackage{fancyhdr}
\usepackage{extramarks}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{tikz}
\usepackage[plain]{algorithm}
\usepackage{algpseudocode}
\usepackage{enumerate}
\usepackage{mathtools}
\usepackage{forest}
\usepackage{adjustbox}
\usepackage[table]{colortbl}

\usetikzlibrary{automata,positioning}

%
% Basic Document Settings
%

\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1}

\pagestyle{fancy}
\lhead{\hmwkAuthorName}
\chead{\hmwkClass\ (\hmwkClassInstructor\ \hmwkClassTime): \hmwkTitle}
\rhead{\firstxmark}
\lfoot{\lastxmark}
\cfoot{\thepage}

\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}

\setlength\parindent{0pt}

%
% Create Problem Sections
%

\newcommand{\enterProblemHeader}[1]{
    \nobreak\extramarks{}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
    \nobreak\extramarks{Problem \arabic{#1} (continued)}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
}

\newcommand{\exitProblemHeader}[1]{
    \nobreak\extramarks{Problem \arabic{#1} (continued)}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
    \stepcounter{#1}
    \nobreak\extramarks{Problem \arabic{#1}}{}\nobreak{}
}

\setcounter{secnumdepth}{0}
\newcounter{partCounter}
\newcounter{homeworkProblemCounter}
\setcounter{homeworkProblemCounter}{1}
\nobreak\extramarks{Problem \arabic{homeworkProblemCounter}}{}\nobreak{}

%
% Homework Problem Environment
%
% This environment takes an optional argument. When given, it will adjust the
% problem counter. This is useful for when the problems given for your
% assignment aren't sequential. See the last 3 problems of this template for an
% example.
%
\newenvironment{homeworkProblem}[1][-1]{
    \ifnum#1>0
        \setcounter{homeworkProblemCounter}{#1}
    \fi
        \section{Problem \arabic{homeworkProblemCounter}}
    \setcounter{partCounter}{1}
    \enterProblemHeader{homeworkProblemCounter}
}{
    \exitProblemHeader{homeworkProblemCounter}
}

%
% Homework Details
%   - Title
%   - Due date
%   - Class
%   - Section/Time
%   - Instructor
%   - Author
%

\newcommand{\hmwkTitle}{Theory Assignment\ \#3}
\newcommand{\hmwkDueDate}{April 6, 2016}
\newcommand{\hmwkClass}{CS 375}
\newcommand{\hmwkClassInstructor}{Professor Lei Yu}
\newcommand{\hmwkClassTime}{Section B1}
\newcommand{\hmwkAuthorName}{Tim Hung}

%
% Title Page
%

\title{
    \vspace{2in}
    \textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
    \normalsize\vspace{0.1in}\small{Due\ on\ \hmwkDueDate\ at 2:20pm}\\
    \vspace{0.1in}\large{\textit{\hmwkClassInstructor\ \hmwkClassTime}}\\
    \vspace{1in}\large{
        I have done this assignment completely on my own. I have not copied it, nor have I given my solution to anyone else. I understand that if I am involved in plagiarism or cheating I will have to sign an official form that I have cheated and that this form will be stored in my official university record. I also understand that I will receive a grade of 0 for the involved assignment for my first offense and that I will receive a grade of “F” for the course for any additional offense.
    }
    \vspace{1in}
}

\author{\textbf{\hmwkAuthorName}}
\date{}

\renewcommand{\part}[1]{\textbf{\large Part \Alph{partCounter}}\stepcounter{partCounter}\\}

%
% Various Helper Commands
%

% Useful for algorithms
\newcommand{\alg}[1]{\textsc{\bfseries \footnotesize #1}}

% For derivatives
\newcommand{\deriv}[1]{\frac{\mathrm{d}}{\mathrm{d}x} (#1)}

% For partial derivatives
\newcommand{\pderiv}[2]{\frac{\partial}{\partial #1} (#2)}

% Integral dx
\newcommand{\dx}{\mathrm{d}x}

% Alias for the Solution section header
\newcommand{\solution}{\textbf{\large Solution}}

% Probability commands: Expectation, Variance, Covariance, Bias
\newcommand{\E}{\mathrm{E}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\Bias}{\mathrm{Bias}}

\begin{document}

\maketitle

\pagebreak

\begin{homeworkProblem} 
(10 points) Suppose the capacity of the knapsack is 30 and the set of items
    \begin{verbatim}
        S = {
            (item1, 5, $50), 
            (item2, 20, $140), 
            (item3, 10, $60), 
            (item4, 10, $80)
        } 
    \end{verbatim}
where each element of set S represents (item, weight, profit). Find an optimal solution for the fractional knapsack problem using the greedy algorithm introduced in class. Show both the order in which the items are selected and the optimal solution you find.

    \begin{center}
        \begin{tabular}{| c | c | c | c |}\hline
            Item    &   Weight  &   Profit  &   Value   \\\hline\hline
            1 & 5  & \$50  & 10 \\\hline
            2 & 20 & \$140 & 7  \\\hline
            3 & 10 & \$60  & 6  \\\hline
            4 & 10 & \$80  & 8  \\\hline
        \end{tabular}
    \end{center}

    \begin{center}
        \begin{tabular}{| c | c | c | c |}\hline
            Item    &   Quantity &  Total Value &   Capacity\\\hline\hline
            1 & 5  & \$50  & 25\\\hline
            4 & 10 & \$130 & 15\\\hline
            2 & 15 & \$235 & 0 \\\hline
        \end{tabular}

    \end{center}
\end{homeworkProblem}

\begin{homeworkProblem}
(30 points) Find a longest common subsequence (LCS) between two strings X = APPLE and Y = PLATE using the dynamic programming algorithm discussed in class. Provide your solution steps in a table that includes the solutions for all possible subproblems and directed arrows (diagonal, left, and up arrows) needed to find an LCS in the end.\\ 

(20 points) Use the recursive method discussed in class to find an LCS based on the information stored in the table. \\

(5 points) Note: show both an LCS and the path that leads to the LCS. 

    \begin{center}
        \begin{tabular}{ | c || c | c | c | c | c | c |}\hline
                & x & A & P & \textbf{P} & \textbf{L} & \textbf{E} \\\hline\hline
            y   & 0 & 0 & \cellcolor{blue!25}0 & 0 & 0 & 0 \\\hline
    \textbf{P}  & 0 & $\uparrow$0 & $\nwarrow$1 & \cellcolor{blue!25}$\nwarrow$\textbf{1} & $\leftarrow$1 & $\leftarrow$1 \\\hline
    \textbf{L}  & 0 & $\uparrow$0 & $\uparrow$1 & $\uparrow$1 & \cellcolor{blue!25}$\nwarrow$\textbf{2} & $\leftarrow$2 \\\hline
            A   & 0 & $\nwarrow$1 & $\uparrow$1 & $\uparrow$1 & \cellcolor{blue!25}$\uparrow$2 & $\uparrow$2 \\\hline
            T   & 0 & $\uparrow$1 & $\uparrow$1 & $\uparrow$1 & \cellcolor{blue!25}$\uparrow$2 & $\uparrow$2 \\\hline
    \textbf{E}  & 0 & $\uparrow$1 & $\uparrow$1 & $\uparrow$1 & $\uparrow$2 & \cellcolor{blue!25}$\nwarrow$\textbf{3} \\\hline
        \end{tabular}
    \end{center}

    The longest common subsequence is "\textbf{PLE}".
\end{homeworkProblem}

\pagebreak

\begin{homeworkProblem}
(10 points) Briefly describe how to extend the depth first search (DFS) algorithm to determine whether a directed graph has a cycle (You may give a sketch of pseudo code and highlight the lines that are different from the original DFS algorithm. Comment your pseudo code to make it easy to understand).

\begin{verbatim}
DFS(G)
    for each u in V(G)
        u.color = WHITE
    for each u in V(G)
        if u.color == WHITE
            DFS-VISIT(G, u)

DFS-VISIT(G, u)
    u.color = GREY
    for each v in Adj(u)
        if v.color == WHITE
            DFS-VISIT(G, v)
        else if v.color == GREY
            print "There's a cycle woah!!!!"
    u.color = BLACK

\end{verbatim}

\end{homeworkProblem}

\pagebreak

\begin{homeworkProblem}
(15 points) In graph theory, a connected component of an undirected graph is a subgraph in which any two vertices are reachable to each other (i.e., connected by at least one path), but the subgraph is not connected to any additional vertices in the supergraph. Briefly describe how to extend the breadth first search (BFS) algorithm to determine the number of connected components in an undirected graph (You may give a sketch of pseudo code and highlight the lines that are different from the original BFS algorithm. Comment your pseudo code to make it easy to understand).

\begin{verbatim}
int components = 0
BFS(G)
    for each u in V(G)
        u.color = WHITE
    for each u in V(G)
        if u.color == WHITE
            components++
            BFS-VISIT(G, u)
BFS(G, u)
    u.color = GREY
    Queue q;
    q.enqueue(u)
    while(q != empty)
        v = q.dequeue
        for each w in Adj(v)
            if(w.color == WHITE)
                w.color = gray
                q.enqueue(w)
        v.color = black
printf("Graph has %d components!", components)
\end{verbatim}

\end{homeworkProblem}

\pagebreak

\begin{homeworkProblem}
(10 points) Enumerate the nodes in the following graph in (a) BFS order and (b) DFS order, starting from node 1. 

\begin{figure}[here]
    \centering
    \begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto]
        \node[shape=circle,draw=black] (1) at (2,2)    {$1$};
        \node[shape=circle,draw=black] (2) at (.5,1)   {$2$};
        \node[shape=circle,draw=black] (3) at (2,1)    {$3$};
        \node[shape=circle,draw=black] (4) at (3.5,1)  {$4$};
        \node[shape=circle,draw=black] (5) at (0,0)    {$5$};
        \node[shape=circle,draw=black] (6) at (1,0)   {$6$};
        \node[shape=circle,draw=black] (7) at (2,0)    {$7$};

        \path [->] (1) edge (2);
        \path [->] (1) edge (3);
        \path [->] (1) edge (4);
        \path [->] (2) edge (5);
        \path [->] (2) edge (6);
        \path [->] (3) edge (7);

    \end{tikzpicture}
    \caption{This sure is a graph right here yes it is.}
    \label{fig:multiple5}
\end{figure}

\textbf{Solution}

    \begin{enumerate}[a)]
        \item
            BFS: 1, 2, 3, 4, 5, 6, 7
        \item  
            DFS: 1, 2, 5, 6, 3, 7, 4
    \end{enumerate}

\end{homeworkProblem}

\begin{homeworkProblem}
(25 points) For each node u in an undirected graph $G(V, E)$, let sDegree(u) be the sum of the degrees of the neighbors of u, that is, $sDegree(u) = \sum_{(u,v)\in E}{Degree(v)}$. Given an adjacency-list implementation of a graph $G(V, E)$, provide pseudo code (comment your pseudo code to make it easy to understand) for an $O(|V|+|E|)$ algorithm that outputs for each node u its sDegree(u) (20 points), and  briefly analyze the time complexity of your algorithm to justify it is $O(|V|+|E|)$. (5 points)  

\begin{verbatim}
degrees = int[V(G).size()]
degrees = 0

for i; i < adjList.size(); i++
    degrees[i] = adjList[i].size()

for i; i < adjList.size(); i++
    int sDeg = 0
    for each u in adjList[i]
        sDeg = degrees[u]
    printf("sDegree(node %d) = %d", i, sDeg)
\end{verbatim}


\end{homeworkProblem}

\begin{homeworkProblem}
Bonus
\end{homeworkProblem}
\end{document}
